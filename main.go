//este programa crea un archivo .ino de un archivo duck ya compilado a bin.
package main

import (
	// "encoding/hex"
	
	"bufio"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strconv"
	"path/filepath"
	"github.com/fatih/color"
)

func encode(file string) {
	// cmd := exec.Command("python", "./lib/main.py", "-i", file, "-o", "war.bin", "-l", "es")
	cmd := exec.Command("./lib/main.exe", "-i", file, "-o", "war.bin", "-l", "es")
	err := cmd.Run()
	if err != nil {
		color.Red("\nespecified file not found")
		os.Exit(2)
	}
}

func customencode(digit byte) string {

	//muestra cada caracter en hexadecimal
	newdigit := uint8(digit)
	real := fmt.Sprintf("0x%x", newdigit)
	return real

}

func generate_source(payload []byte, init_delay int, loop_count int, loop_delay int, blink bool) string {

	//convierte int en string
	delay := strconv.Itoa(init_delay)
	//loop := strconv.Itoa(loop_count)
	loop_del := strconv.Itoa(loop_delay)

	// Plantilla usada para el archivo .ino
	var head string = `/*
* Sketch generated by duck2spark from ertiti11 with go
*
*/
#include "DigiKeyboard.h"
`
	var init string = `
void setup()
{
	// initialize the digital pin as an output.
	pinMode(0, OUTPUT); //LED on Model B
	pinMode(1, OUTPUT); //LED on Model A
	DigiKeyboard.delay(` + delay + `); 
}
void loop()
{
`
	var body string = `
	//should code be runned in this loop?
	if (i != 0) {
		DigiKeyboard.sendKeyStroke(0);
		//parse raw duckencoder script
		for (int i=0; i<DUCK_LEN; i+=2)
		{
			uint8_t key = pgm_read_word_near(duckraw + i);
			uint8_t mod = pgm_read_word_near(duckraw + i+1);
			if (key == 0) //delay (a delay>255 is split into a sequence of delays)
			{
				DigiKeyboard.delay(mod);
			}
			else DigiKeyboard.sendKeyStroke(key,mod);
		}
		i--;
		DigiKeyboard.delay(` + loop_del + `); 
	}
	else if (blink)
	{
		digitalWrite(0, HIGH);   // turn the LED on (HIGH is the voltage level)
		digitalWrite(1, HIGH);
		delay(100);               // wait for a second
		digitalWrite(0, LOW);    // turn the LED off by making the voltage LOW
		digitalWrite(1, LOW);
		delay(100);               // wait for a second
	}
`
	var tail string = "}"

	// almacena en una variable la longitud del payload=raw.bin
	var l int = len(payload)

	// convierte cada caracter en un array de valores hexadecimales
	var declare = "#define DUCK_LEN " + fmt.Sprintf("%d", l) + "\nconst PROGMEM uint8_t duckraw [DUCK_LEN] = {\n\t"
	for i := 0; i < l-1; i++ {
		declare += customencode(payload[i]) + ", "

	}
	declare += customencode(payload[l-1]) + "\n};\nint i = 1; //how many times the payload should run (-1 for endless loop)\n"
	declare += "bool blink=true;\n"

	var returned = head + declare + init + body + tail
	return returned
}

func write_data(digiscript string) {

	f, err := os.Create("sketch.ino")
	if err != nil {
		color.Red("\nNo se pudo crear el archivo temporal de arduino")
		
	}

	defer f.Close()

	_, err2 := f.WriteString(digiscript)

	if err2 != nil {
		log.Fatal(err2)
	}
}

func main() {
	arg_len := len(os.Args[1:])
	if arg_len < 1 {
		fmt.Printf("digiducky [file] -l [layout] (es, eng, ...)")
		os.Exit(1)
	}

	
	file, errr := filepath.Abs(os.Args[1])
	
    if errr != nil {

        log.Fatal(errr)
    }
	
	encode(file)
	payload, error := GetFile("war.bin")
	if error != nil {
		fmt.Println(error)
	}

	// payload := string(data)
	digiscript := generate_source(payload, 2500, 1, 5000, true)
	write_data(digiscript)
	err := os.Remove("war.bin")

	if err != nil {
		fmt.Println(err)
		return
	}
	compile()

	// fmt.Print(generate_source(payload, 2500, 1, 5000, true))
}

func GetFile(filename string) ([]byte, error) {
	file, err := os.Open(string(filename))

	if err != nil {
		return nil, err
	}
	defer file.Close()

	stats, statsErr := file.Stat()
	if statsErr != nil {
		return nil, statsErr
	}

	var size int64 = stats.Size()
	bytes := make([]byte, size)

	bufr := bufio.NewReader(file)
	_, err = bufr.Read(bytes)

	return bytes, err
}

func compile() {
	color.Yellow("compilando...\n")
	compile := exec.Command("./lib/arduino.exe", "compile", "-b", "digistump:avr:digispark-tiny")
	compile_rr := compile.Run()
	if compile_rr != nil {
		color.Red("no se pudo compilar el sketch")
		os.Exit(1)
	}
	color.Green("compilado \n")
	color.Green("Tienes 60 seg para introducir el dispositivo \n")
	// go func() {
	// 	time.Sleep(2 * time.Second)
	// 	color.Green("Introduce el digispark en un puerto usb (tiempo restante 60 seg....")

	// }()

	upload := exec.Command("./lib/arduino.exe", "upload", "-b", "digistump:avr:digispark-tiny")
	upload_err := upload.Run()
	if upload_err != nil {
		log.Fatal(upload_err)
	}
	color.Green("subido? \n")

}
